#include <linux/pagemap.h>
#include "amfs.h"

/*Exposed API Scan the complete file and 
check for patterns split across boundaries*/
#ifdef EXTRA_CREDIT
int scan_file(struct file *file, struct file *lower_file)
{
	int err = SAFE_FILE;
	size_t rem_bytes = 0;
	long num_pages = 0;
	int page_index = 0;
	char *buffer = NULL;
	char *ptr = NULL;
	size_t buff_len = PAGE_CACHE_SIZE;
	size_t size = 0;
	struct super_block *sb = NULL;
	struct inode *inode = NULL;
	loff_t file_size = 0;
	loff_t patt_size = 0;
	mm_segment_t oldfs;
	struct list_head *pattern_list_head = NULL;
	struct amfs_pattern *amfs_patt = NULL;
	char *partial_matched_patt = NULL;
	int rem_chars = 0;

	inode = lower_file->f_inode;
	file_size = inode->i_size;
	if (file_size == 0)
		goto out; /*No malware to check, return*/

	buffer = kzalloc(buff_len, GFP_KERNEL);
	if (!buffer || IS_ERR(buffer)) {
		err = PTR_ERR(buffer);
		goto out;
	}
	sb = file->f_inode->i_sb;
	pattern_list_head = &(AMFS_SB(sb)->pattern_db.head);
	if (!pattern_list_head) {
		err = -EINVAL;
		goto out;
	}

	oldfs = get_fs();
	set_fs(KERNEL_DS);
	num_pages = file_size / PAGE_CACHE_SIZE;
	rem_bytes = file_size % PAGE_CACHE_SIZE;
	while (page_index <= num_pages) {
		if (page_index == num_pages && rem_bytes > 0)
			buff_len = rem_bytes;
		err = vfs_read(lower_file, buffer, buff_len,
			       &lower_file->f_pos);
		if (err < 0) {
			err = -EIO;
			goto out_err;
		}

		if (rem_bytes >= rem_chars && rem_chars > 0 &&
		    !memcmp(buffer, partial_matched_patt, rem_chars)) {
			err = MALICIOUS_FILE;
			goto out_err;
		}
		partial_matched_patt = NULL;
		rem_chars = 0;
		list_for_each_entry(amfs_patt,
				    pattern_list_head, pattern_list) {
			ptr = buffer;
			size = buff_len;
			patt_size = strlen(amfs_patt->pattern);

			while (size >= patt_size) {
				size--;
				if (!memcmp(ptr,
					    amfs_patt->pattern, patt_size)) {
					err = MALICIOUS_FILE;
					goto out_err;
				}
				ptr++;
			}
			while (size > 0) {
				if (!memcmp(ptr, amfs_patt->pattern, size)) {
					partial_matched_patt =
					amfs_patt->pattern + size;
					rem_chars = patt_size - size;
				}
				ptr++;
				size--;
			}
		}
		page_index++;
	}
out_err:
	set_fs(oldfs);
out:
	return err;
}

#endif

/*Add pattern to linked list*/
int __add_pattern_to_list(struct list_head *pattern_list_head,
			  char *patt_start, loff_t patt_size)
{
	int err = 0;
	char *pattern = NULL;
	struct amfs_pattern *amfs_patt = NULL;

	/*Avoid duplicate patterns*/
	list_for_each_entry(amfs_patt, pattern_list_head, pattern_list) {
		if (!memcmp(patt_start, amfs_patt->pattern, patt_size)) {
			err = -EINVAL;
			goto out;
		}
	}
	pattern = kzalloc(patt_size + 1, GFP_KERNEL);
	if (!pattern || IS_ERR(pattern)) {
		err = PTR_ERR(pattern);
		goto out;
	}
	/*Copy current pattern into pattern object on physical m/m*/
	strcpy(pattern, patt_start);
	/*Create amfs_pattern node object*/
	amfs_patt = kzalloc(sizeof(struct amfs_pattern), GFP_KERNEL);
	if (!amfs_patt || IS_ERR(amfs_patt)) {
		err = PTR_ERR(amfs_patt);
		goto out_clean;
	}
	/*Attach pattern object to amfs_pattern node*/
	amfs_patt->pattern = pattern;
	/*Add pattern node to linked list*/
	list_add_tail(&amfs_patt->pattern_list, pattern_list_head);

out_clean:
	if (err)
		kfree(pattern);
out:
	return err;
}

/*Remove paatern from linked list*/
int __remove_pattern_from_list(struct list_head *pattern_list_head,
			       char *pattern, loff_t patt_size)
{
	struct amfs_pattern *curr_patt = NULL;
	struct list_head *curr = NULL;
	struct list_head *next = NULL;
	int patt_found = 0;
	int err = 0;

	if (list_empty(pattern_list_head)) {
		err = -EINVAL;
		goto out;
	}

	list_for_each_safe(curr, next, pattern_list_head) {
		curr_patt = list_entry(curr, struct amfs_pattern, pattern_list);
		if (!memcmp(pattern, curr_patt->pattern, patt_size)) {
			patt_found = 1;
			kfree(curr_patt->pattern); /*free pattern m/m*/
			/*remove pattern obj from list*/
			list_del(&(curr_patt->pattern_list));
			kfree(curr_patt);/* free pattern obj m/m*/
		}
	}
	if (!patt_found)
		err = -EINVAL;
out:
	return err;
}

/*Read patterns from pattern db file*/
int __read_patterns_from_pattdb(struct super_block *sb,
				struct file *patt_filp, loff_t pattfile_size)
{
	int err = 0;
	int page_count = 0;
	int index = 0;
	size_t read_bytes = 0;
	size_t buff_len = PAGE_CACHE_SIZE;
	loff_t last_patt_start_pos = 0;
	char *buff = NULL;
	char *patt_start = NULL;
	char *patt_end = NULL;
	mm_segment_t oldfs;
	struct list_head *pattern_list_head = NULL;

	buff = kzalloc(buff_len, GFP_KERNEL);
	if (!buff || IS_ERR(buff)) {
		err = PTR_ERR(buff);
		goto out;
	}
	/*Create linked list head*/
	pattern_list_head = &(AMFS_SB(sb)->pattern_db.head);
	INIT_LIST_HEAD(pattern_list_head);

	oldfs = get_fs();
	set_fs(KERNEL_DS);
	while (patt_filp->f_pos < pattfile_size) {
		index = 0;
		read_bytes = patt_filp->f_op->read(patt_filp,
			buff, buff_len, &patt_filp->f_pos);
		if (read_bytes < 0) {
			err = -EIO;
			goto out;
		} else if (read_bytes < buff_len) {
			buff[read_bytes] = '\n';
		}
		patt_start = buff;
		patt_end = buff;
		while (index <= read_bytes) {
			if (*patt_end == '\n') {
				*patt_end = '\0';
				if (*patt_start != '\0') {
					/*Create pattern object*/
					err = __add_pattern_to_list(
						pattern_list_head,
						patt_start,
						patt_end - patt_start);
					if (err)
						goto out;
				}
				patt_start = patt_end + 1;
				last_patt_start_pos = index + 1;
				patt_end = patt_start;
			} else {
				patt_end++;
			}
			index++;
		}
		/*Reset last pattern starting index to 0
		if it goes out of read bytes limit*/
		if (last_patt_start_pos >= read_bytes)
			last_patt_start_pos = 0;
		if (read_bytes == buff_len)
			patt_filp->f_pos = (page_count * buff_len)
				+ last_patt_start_pos;
		page_count++;
	}
	set_fs(oldfs);
out:
	/*TODO free linked list if failure*/
	kfree(buff);
	return err;
}

/*Add pattern to db file*/
int __add_pattern_to_db(struct file *file, char *kpattern, size_t patt_len)
{
	int err = 0;
	struct super_block *sb = NULL;
	struct list_head *pattern_list_head = NULL;
	char *db_path = NULL;
	struct file *patt_filp = NULL;
	struct amfs_pattern *amfs_patt = NULL;
	char nl = '\n';
	mm_segment_t old_fs;

	sb = file->f_inode->i_sb;
	if (!sb) {
		err = -EINVAL;
		goto out;
	}

	pattern_list_head = &(AMFS_SB(sb)->pattern_db.head);
	if (!pattern_list_head) {
		err = -EINVAL; /*TODO decide on error to return*/
		goto out;
	}
	/* It createa buffer of len+1 size,
	so pass pattern string length only*/
	err = __add_pattern_to_list(pattern_list_head, kpattern, patt_len);
	if (err)
		goto out;

	/*Add pattern to  pattern db file too*/
	db_path = AMFS_SB(sb)->pattern_db.db_path;
	patt_filp = filp_open(db_path, O_WRONLY | O_TRUNC, 0);
	if (!patt_filp || IS_ERR(patt_filp)) {
		err = PTR_ERR(patt_filp);
		goto out;
	}

	old_fs = get_fs();
	set_fs(KERNEL_DS);
	/*write to pattern db*/
	list_for_each_entry(amfs_patt, pattern_list_head, pattern_list) {
		patt_filp->f_op->write(patt_filp, amfs_patt->pattern,
			strlen(amfs_patt->pattern), &patt_filp->f_pos);
		patt_filp->f_op->write(patt_filp, &nl,
			sizeof(char), &patt_filp->f_pos);
	}
	set_fs(old_fs);
	filp_close(patt_filp, NULL);
	AMFS_SB(sb)->pattern_db.version++;
out:
	return err;
}

/*Remove pattern from db file.*/
int __remove_pattern_from_db(struct file *file,
			     char *kpattern, size_t patt_len)
{
	int err = 0;
	struct super_block *sb = NULL;
	struct list_head *pattern_list_head = NULL;
	char nl = '\n';
	char *db_path = NULL;
	struct file *patt_filp = NULL;
	struct amfs_pattern *amfs_patt = NULL;
	mm_segment_t old_fs;

	sb = file->f_inode->i_sb;
	if (!sb) {
		err = -EINVAL;
		goto out;
	}

	pattern_list_head = &(AMFS_SB(sb)->pattern_db.head);
	if (!pattern_list_head) {
		err = -EINVAL; /*TODO decide on error to return*/
		goto out;
	}
	/*It creates buffer of len+1 size, so pass pattern string length only*/
	err = __remove_pattern_from_list(pattern_list_head, kpattern, patt_len);
	if (err)
		goto out;
	/*remove pattern from pattern db file too*/
	db_path = AMFS_SB(sb)->pattern_db.db_path;

	patt_filp = filp_open(db_path, O_CREAT | O_WRONLY | O_TRUNC, 0);
	if (!patt_filp || IS_ERR(patt_filp)) {
		err = PTR_ERR(patt_filp);
		goto out;
	}
	old_fs = get_fs();
	set_fs(KERNEL_DS);
	/*write to pattern db*/
	list_for_each_entry(amfs_patt, pattern_list_head, pattern_list) {
		patt_filp->f_op->write(patt_filp,
			amfs_patt->pattern,
			strlen(amfs_patt->pattern),
			&patt_filp->f_pos);
		patt_filp->f_op->write(patt_filp, &nl, sizeof(char),
			&patt_filp->f_pos);
	}
	set_fs(old_fs);
	filp_close(patt_filp, NULL);
	AMFS_SB(sb)->pattern_db.version++;
out:
	return err;
}

/*Exposed API for adding new pattern*/
int add_pattern(struct file *file, void *arg)
{
	int err = 0;
	size_t patt_len = 0;
	struct pattern_data *patt = NULL;
	char *kpattern = NULL;

	if (!access_ok(VERIFY_READ,
		       (struct pattern_data *)arg,
		       sizeof(struct pattern_data))) {
		err = -EFAULT;
		goto out;
	}
	patt = (struct pattern_data *)arg;
	patt_len = patt->data_len;

	kpattern = kzalloc(patt_len + sizeof(char), GFP_KERNEL);
	if (!kpattern || IS_ERR(kpattern)) {
		err = PTR_ERR(kpattern);
	    goto out;
	}
	err = copy_from_user(kpattern, patt->data, patt_len + sizeof(char));
	if (err) {
		err = -EFAULT;
		goto out;
	}
	/*Add pattern to patterns db*/
	err = __add_pattern_to_db(file, kpattern, patt_len);

out:
	kfree(kpattern);
	return err;
}

/*Exposed API for removing new pattern*/
int remove_pattern(struct file *file, void *arg)
{
	int err = 0;
	size_t patt_len = 0;
	struct pattern_data *patt = NULL;
	char *kpattern = NULL;

	if (!access_ok(VERIFY_READ,
		       (struct pattern_data *)arg,
		       sizeof(struct pattern_data))) {
		err = -EFAULT;
		goto out;
	}
	patt = (struct pattern_data *)arg;
	patt_len = patt->data_len;
	kpattern = kzalloc(patt_len + sizeof(char), GFP_KERNEL);
	if (!kpattern || IS_ERR(kpattern)) {
		err = PTR_ERR(kpattern);
	    goto out;
	}
	err = copy_from_user(kpattern, patt->data, patt_len + sizeof(char));
	if (err) {
		err = -EFAULT;
		goto out;
	}
	/*Remove pattern from db*/
	err = __remove_pattern_from_db(file, kpattern, patt_len);

out:
	kfree(kpattern);
	return err;
}

/*Exposed API for listing patterns*/
int list_patterns(struct file *file, void *arg)
{
	int err = 0;
	size_t patt_len = 0;
	struct super_block *sb = NULL;
	struct list_head *pattern_list_head = NULL;
	struct amfs_pattern *amfs_patt = NULL;
	struct pattern_data *user_arg = NULL;
	char *user_buff = NULL;
	char nl = '\n';

	user_arg = (struct pattern_data *)arg;
	if (!user_arg ||
	    !access_ok(VERIFY_READ, user_arg,
	    sizeof(struct pattern_data))) {
		err = -EFAULT;
		goto out;
	}
	if (!user_arg->data ||
	    !access_ok(VERIFY_WRITE,
	    (char *)user_arg->data, user_arg->data_len)) {
		err = -EFAULT;
		goto out;
	}
	sb = file->f_inode->i_sb;
	if (!sb) {
		err = -EINVAL;
		goto out;
	}
	pattern_list_head = &(AMFS_SB(sb)->pattern_db.head);
	if (!pattern_list_head) {
		err = -EINVAL;
		goto out;
	}
	user_buff = user_arg->data;
	list_for_each_entry(amfs_patt, pattern_list_head, pattern_list) {
		patt_len = strlen(amfs_patt->pattern) * sizeof(char);
		/*Policy: Read complete-patterns upto the user buff size,
		no partial pattern allowed
		*/
		if ((user_buff - user_arg->data) >
			 (user_arg->data_len - patt_len))
			break;
		err = copy_to_user(user_buff, amfs_patt->pattern, patt_len);
		if (err) {
			err = -EFAULT;
			goto out;
		}
		user_buff += patt_len;
		err = copy_to_user(user_buff, &nl, sizeof(char));
		user_buff += sizeof(char);
		if (err)
			goto out;
	}
out:
	return err;
}

/*Exposed API to get the file safety status*/
int get_file_status(struct dentry *dentry)
{
	int status = UNKNOWN_FILE;
	int version = 0;
	int err = 0;

	if (!S_ISREG(dentry->d_inode->i_mode))
		goto out;
	err = vfs_getxattr(dentry, AMFS_XATTR_STATUS, &status, sizeof(int));
	err = vfs_getxattr(dentry, AMFS_XATTR_VERSION, &version, sizeof(int));

	if (!err)
		status = UNKNOWN_FILE;

	if (AMFS_SB(dentry->d_sb)->pattern_db.version != version)
		status = UNKNOWN_FILE;
out:
	return status;
}

/*Exposed API to set the file safety status 
and pattern db version*/
int set_file_status(struct dentry *dentry, int status)
{
	mm_segment_t old_fs;
	int err = 0;
	int version = 0;

	if (!S_ISREG(dentry->d_inode->i_mode)) {
		err = -EPERM;
		goto out;
	}

	version = AMFS_SB(dentry->d_sb)->pattern_db.version;
	old_fs = get_fs();
	set_fs(KERNEL_DS);
	err = vfs_setxattr(dentry,
			   AMFS_XATTR_STATUS,
			   &status, sizeof(int), 0);
	err = vfs_setxattr(dentry,
			   AMFS_XATTR_VERSION,
			   &version, sizeof(int), 0);
	set_fs(old_fs);
out:
	return err;
}

/*Exposed API Scan buffer against all patterns in db*/
int scan_buff(struct file *file, const char __user *buf, size_t count)
{
	int err = 0;
	struct super_block *sb = NULL;
	struct list_head *pattern_list_head = NULL;
	struct amfs_pattern *amfs_patt = NULL;
	char *data_buff = NULL;
	char *ptr = NULL;
	int patt_size = 0;
	size_t size = 0;

	data_buff = kzalloc(count, GFP_KERNEL);
	if (!data_buff || IS_ERR(data_buff)) {
		err = -EFAULT;
		goto out;
	}
	err = copy_from_user(data_buff, buf, count);
	if (err) {
		err = -EFAULT;
		goto out;
	}
	sb = file->f_inode->i_sb;
	pattern_list_head = &(AMFS_SB(sb)->pattern_db.head);
	if (!pattern_list_head) {
		err = -EINVAL;
		goto out;
	}
	list_for_each_entry(amfs_patt, pattern_list_head, pattern_list) {
		ptr = data_buff;
		size = count;
		patt_size = strlen(amfs_patt->pattern);
		while (size >= patt_size) {
			size--;
			if (!memcmp(ptr, amfs_patt->pattern, patt_size)) {
				err = MALWARE;
				goto out;
			}
			ptr++;
		}
	}
out:
	kfree(data_buff);
	return err;
}

/*Exposed API for creating pattern linked list*/
int create_pattern_list(char *pattdb_path, struct super_block *sb)
{
	int err = 0;
	loff_t pattfile_size = 0;
	struct file *patt_filp = NULL;
	struct inode *pattfile_inode = NULL;

	/*Open pattern db file & read all patterns*/
	patt_filp = filp_open(pattdb_path,  O_RDONLY, 0);
	if (!patt_filp || IS_ERR(patt_filp)) {
		err = PTR_ERR(patt_filp);
		goto out;
	}
	if (!S_ISREG(patt_filp->f_inode->i_mode)) {
		err = -EINVAL;
		goto out_close;
	}
	/*Check for pattern db file read permission*/
	if (!(patt_filp->f_mode & FMODE_READ) || !patt_filp->f_op->read) {
		err = -EBADF;
		goto out_close;
	}
	pattfile_inode = patt_filp->f_path.dentry->d_inode;
	pattfile_size = pattfile_inode->i_size;
	/*Check for pattern db file size*/
	if (pattfile_size == 0) {
		err = -EINVAL;
		goto out_close;
	}
	/*Read pattern file and create linked list of patterns*/
	err = __read_patterns_from_pattdb(sb, patt_filp, pattfile_size);
out_close:
	if (patt_filp)
		filp_close(patt_filp, NULL);
out:
	return err;
}
