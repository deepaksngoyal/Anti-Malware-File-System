#include<stdio.h>
#include<sys/ioctl.h>
#include<fcntl.h>
#include<stdlib.h>
#include<string.h>
#include <unistd.h>

struct pattern_data {
	char *data;
	size_t data_len;
};

#define PATTDB_MAGIC 'P'
#define ADD_PATT_IOCTL _IOW(PATTDB_MAGIC, 0, struct pattern_data *)
#define REMOVE_PATT_IOCTL _IOW(PATTDB_MAGIC, 1, struct pattern_data *)
#define LIST_PATT_IOCTL _IOR(PATTDB_MAGIC, 2, struct pattern_data *)

#define ADD_PATTERN 0
#define REMOVE_PATTERN 1
#define LIST_PATTERNS 2
#define BUFFER_SIZE (256*256)

int parse_patterns_list(struct pattern_data *usr_patt);

int main(int argc, char * const argv[])
{
	struct pattern_data *usr_patt;
	char *pattern = NULL;
	char *mount_point = NULL;
	int fd = -1;
	int flag = -1;
	int err = 0;
	int opt = 0;
	extern char *optarg;
	extern int optind;
	static const char *optString =  "a:r:l";

	while ((opt = getopt(argc, argv, optString)) != -1) {
		switch (opt) {
		case 'a':
			flag = ADD_PATTERN;
			pattern = optarg;
			break;
		case 'r':
			flag = REMOVE_PATTERN;
			pattern = optarg;
			break;
		case 'l':
			flag = LIST_PATTERNS;
			break;
		case '?':
			flag = -1;
			break;
		}
	}
	if (flag == -1) {
		fprintf(stderr, "Error, wrong option\n");
		exit(1);
	} else if (optind + 1 > argc) {
		fprintf(stderr, "Error, missing mount point\n");
		exit(1);
	}
	mount_point = argv[optind];
	fd = open(mount_point, O_RDONLY);
	if (fd < 0) {
		perror("Error in file open.\n");
		exit(1);
	}
	usr_patt = (struct pattern_data *)malloc(sizeof(struct pattern_data));
	if (flag == ADD_PATTERN || flag == REMOVE_PATTERN) {
		usr_patt->data = pattern;
		usr_patt->data_len = strlen(pattern);
	} else {
		usr_patt->data  = malloc(BUFFER_SIZE);
		usr_patt->data_len = BUFFER_SIZE;
	}

	switch (flag) {
	case ADD_PATTERN:
		err = ioctl(fd, ADD_PATT_IOCTL, usr_patt);
		if (err) {
			perror("Error while adding pattern");
			goto out;
		}
		printf("Pattern added!\n");
		break;
	case REMOVE_PATTERN:
		err = ioctl(fd, REMOVE_PATT_IOCTL, usr_patt);
		if (err) {
			perror("Error while removing pattern");
			goto out;
		}
		printf("Pattern removed!\n");
		break;
	case LIST_PATTERNS:
		err = ioctl(fd, LIST_PATT_IOCTL, usr_patt);
		if (err) {
			perror("Error while listing patterns");
			goto out;
		}
		if (parse_patterns_list(usr_patt)) {
			err = -1;
			goto out;
		}
		break;
	}
out:
	if (flag == LIST_PATTERNS && usr_patt != NULL && usr_patt->data != NULL)
		free(usr_patt->data);
	if (usr_patt != NULL)
		free(usr_patt);
	return err;
}

int parse_patterns_list(struct pattern_data *usr_patt)
{
	char *buff = NULL;
	char *pattern = NULL;
	char *delimiter = "\n";

	if (!usr_patt)
		return -1;
	buff = usr_patt->data;
	while ((pattern = strsep(&buff, delimiter)) != NULL) {
		if (!*pattern)
			continue;
		printf("%s\n", pattern);
	}
	return 0;
}
